# Лабораторная работа №3
**Студент:** Руденко Михаил, Б05  
**Тема:** Малоранговые приближения и сжатие изображений  
**Язык программирования:** Python  

---

## 1. Сжатие монохромных изображений при помощи SVD-разложения

### Реализация:

1. **Чтение изображения:**
   - Изображение в формате BMP конвертируется в градации серого (`convert('L')`)
   - Преобразуется в матрицу значений типа `np.float32`

2. **SVD-разложение:**
   - Выполняется SVD-разложение одним из методов (по умолчанию - `numpy.linalg.svd`)
   - Матрица представляется в виде: `M = U × Σ × V^T`

3. **Выбор ранга для сжатия:**
   - Для заданного коэффициента сжатия `N` вычисляется максимальный ранг `r`, удовлетворяющий условию:
     ```
     размер_сжатого_файла ≤ размер_исходного / N
     ```
   - Размер сжатого файла рассчитывается как:
     ```
     r × (rows + cols + 1) × 4 байта
     ```

4. **Сохранение сжатых данных:**
   - Сохраняются первые `r` столбцов матрицы `U`
   - Сохраняются первые `r` сингулярных значений `Σ`
   - Сохраняются первые `r` строк матрицы `V^T`
   - Данные сохраняются в пользовательском формате 

### Восстановление:

1. **Чтение сжатого файла:**
   - Загрузка метаданных (размеры изображения, ранг)
   - Загрузка матриц `U`, `Σ`, `V^T`

2. **Восстановление изображения:**
   - Матрица восстанавливается по формуле: `M_rec = U × diag(Σ) × V^T`
   - Значения обрезаются до диапазона [0, 255]
   - Сохранение в формате BMP

---

## 2. Полиномиальная аппроксимация для поиска чувствительной матрицы

### Поиск оптимальных коэффициентов полинома

Для создания матрицы, которая максимально проявляет различия между алгоритмами SVD, используется следующий подход:

#### **Алгоритм поиска:**
1. **Генерация случайных коэффициентов** многочлена в диапазоне [-10, 10]
2. **Создание матрицы** по формуле полинома от индексов (i, j)%256
3. **Вычисление метрики различия** между SVD-алгоритмами
4. **Сохранение лучших коэффициентов**, дающих максимальное различие

#### **Ключевые функции:**

```python
def calculate_polynom(x, y, c=[0]*10):
    return (c[0] + c[1]*x + c[2]*y+ c[3]*(x**2) + c[4]*(y**2) + c[5]*(x*y) + c[6]*(x**3) + c[7]*(y**3) + c[8]*(x*x*y) + c[9]*(x*y*y)) % 256

def create_matrix(m=800, n=533, coef=[3,-8,4,-1,-10,-10,-1,8,4,-5]):
    M = np.zeros((m, n))
    M = np.fromfunction(lambda i, j: calculate_polynom(i, j, c=coef), (m, n))
    return M

def calculate_difference_metric(M):
    s1 = compute_svd_numpy(M)[1]
    s2 = compute_svd_scipy(M)[1]

    a = np.sort(s1)
    b = np.sort(s2)

    mask = (a != 0) & (b != 0)
    c = np.zeros_like(a)
    c[mask] = np.maximum(a[mask]/b[mask], b[mask]/a[mask])

    return np.linalg.norm(c)

def one_step_opt():
    c = np.random.randint(low=-10, high=10, size=10)
    M = create_matrix(coef=c)
    diff = calculate_difference_metric(M)
    return diff, c
```
закоментированный код - поиск его коэффициентов, дающих матрицу kill_image.bmp